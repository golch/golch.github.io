<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Flask-Login (번역)</title>
  <meta name="description" content="Flask-Login (번역)">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/syntax.css">
  <link rel="canonical" href="http://localhost:4000/flask/2017/06/03/Flask-Login-(%EB%B2%88%EC%97%AD).html">
  <link rel="alternate" type="application/rss+xml" title="GOLCH" href="http://localhost:4000/feed.xml">
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-76613132-3', 'auto');
  ga('send', 'pageview');

</script>

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">GOLCH</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">블로그에 관하여</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Flask-Login (번역)</h1>
    <p class="post-meta"><time datetime="2017-06-03T12:10:20+09:00" itemprop="datePublished">Jun 3, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <h1 id="flask-login-번역">Flask-Login (번역)</h1>

<p>원문 : <a href="https://flask-login.readthedocs.io/en/latest/">https://flask-login.readthedocs.io/en/latest/</a></p>

<blockquote>
  <p><em>마크다운 문법으로 작성했기 때문에, 내부링크가 동작하지 않습니다. 또한 원문 하단의 API 문서는 추후에 다시 번역해서 업로드 하도록 하겠습니다.</em></p>
</blockquote>

<p>플라스크 로그인은 플라스크를 위한 유저 세션 관리를 제공한다. 이것은 장기간에 걸쳐 로그인, 로그아웃, 그리고 당신의 유저의 세션을 기억하는 등의 평범한 업무를 처리한다.</p>

<p>이것은 :</p>

<ul>
  <li>세션 안의 활성 유저의 ID를 저장한다. 그리고 로그인과 로그아웃을 쉽게 해준다.</li>
  <li>로그인 한 유저(혹은 로그아웃 한 유저)로 제한하여 볼 수 있도록 해준다.</li>
  <li>일반적으로 까다로운 “나를 기억하는” 기능성을 처리하도록 해준다.</li>
  <li>쿠키도둑으로부터 당신의 유저세션을 보호하는 것을 도와준다.</li>
  <li>Flask-Principal 이나 다른 권한관리 확장기능과 통합을 가능하게 해준다.</li>
</ul>

<p>그러나 다음은 하지 않는다 :</p>

<ul>
  <li>특정 데이터베이스나 다른 저장방법을 제공하지 않는다. 어떻게 유저를 저장할지는 온전히 당신의 책임이다.</li>
  <li>username과 password를 사용하거나, OpenIDs, 혹은 다른 권한부여 방법을 사용하는 것을 제한하지 않는다.</li>
  <li>“logged in or not” 너머의 권한관리는 처리하지 않는다.</li>
  <li>유저 등록이나 계정 복구는 처리하지 않는다.</li>
</ul>

<h2 id="설치하기">설치하기</h2>

<p>pip를 통한 설치 :</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>pip install flask-login
</code></pre></div></div>

<h2 id="어플리케이션-설정">어플리케이션 설정</h2>

<p>플라스크-로그인을 사용하는데 가장 중요한 부분은 <a href="#flask_login.LoginManager.user_loader">LoginManager</a> class이다. 당신은 어플리케이션을 위해서 코드 어딘가에 아래처럼 하나를 생성해야 한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">login_manager</span> <span class="o">=</span> <span class="n">LoginManager</span><span class="p">()</span>
</code></pre></div></div>

<p>로그인 매니저는 당신의 어플리케이션과 플라스크-로그인이 함께 동작하기 위한 코드를 포함한다. 이것은 유저를 어떻게 불러올 것인지, 유저가 로그인을 원할 때 어디로 보낼 것인지 등의 코드이다.</p>

<p>일단 실제 어플리케이션 오브젝트가 생성되고 나면, 당신은 로그인을 위해 이것을 설정할 수 있다 :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">login_manager</span><span class="o">.</span><span class="n">init_app</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="어떻게-동작하는가">어떻게 동작하는가</h2>

<p>당신은 <a href="#flask_login.LoginManager.user_loader">user_loader</a> 콜백함수를 제공하는 것이 필요할 것이다. 이 콜백함수는 세션에 저장된 유저 ID로부터 유저 객체를 다시 로드하는데 쓰인다. 이것은 유저의 unicode ID를 가져야 하며, 이에 상응하는 유저 객체를 리턴한다. 예제를 보자 :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@login_manager.user_loader</span>
<span class="k">def</span> <span class="nf">load_user</span><span class="p">(</span><span class="n">user_id</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">User</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">user_id</span><span class="p">)</span>
</code></pre></div></div>

<p>만일 ID가 검증되지 않으면 <a href="https://docs.python.org/3/library/constants.html#None">None</a> (exception이 발생하지 않는다!)을 리턴한다(이런 경우에는, 세션에서 ID를 수동으로 제거하고 프로세스는 계속될 것이다.).</p>

<h2 id="당신의-유저-클래스">당신의 유저 클래스</h2>

<p>당신이 유저들을 나타내기위해 사용하는 클래스는 아래의 프로퍼티와 메서드를 구현(implement)한다 :</p>

<p><strong>is_authenticated</strong></p>

<p>만일 유저가 권한을 획득했다면(그들이 유효한 자격증명을 제공했다면) 이 프로퍼티는 <a href="https://docs.python.org/3/library/constants.html#True">True</a>를 리턴해야 한다. (유저가 <a href="#flask_login.login_required">login_required</a>의 기준을 채웠을 때에만 권한을 획득한다.)</p>

<p><strong>is_active</strong></p>

<p>이 유저가 활성 유저이고, 권한을 획득했다면 이 프로퍼티는 <a href="https://docs.python.org/3/library/constants.html#True">True</a>를 리턴해야 한다. 또한 이 유저들은 계정을 활성화했고, 정지되지 않았으며 당신의 어플리케이션이 그 계정을 거부하지 않았어야 한다. 비활성화 된 계정들은 (억지로 그렇게 하지 않는 이상) 로그인이 안 될 것이다.</p>

<p><strong>is_anonymous</strong></p>

<p>만일 익명의 사용자(anonymous user)라면 이 프로퍼티는 <a href="https://docs.python.org/3/library/constants.html#True">True</a>를 리턴해야 한다. (실제 유저라면 대신 <a href="https://docs.python.org/3/library/constants.html#False">False</a>를 리턴한다.)</p>

<p><strong>get_id()</strong></p>

<p>이 메서드는 유니크하게 이 유저를 구분하는 <strong>unicode</strong>를 리턴해야 한다. 또한 이 <strong>unicode</strong>는 <a href="#flask_login.LoginManager.user_loader">user_loader</a> 콜백함수로부터 유저를 불러오는데 사용될 수도 있다. 만일 ID가 내부적으로는 <a href="https://docs.python.org/3/library/functions.html#int">int</a> 이거나 다른 타입이라도 당신은 <strong>unicode</strong>로 변환해야만 한다. 따라서 이것이 <strong>unicode</strong>라는 것을 명심하라.</p>

<p>유저 클래스 구현(implement)하는 것을 쉽게 하기 위해서, 당신은 <a href="#flask_login.UserMixin">UserMixin</a> 으로부터 상속받을 수 있다. UserMixin은 모든 프로퍼티와 메서드를 위해서 디폴트 구현을 제공한다.(물론, 반드시 요구되는 것은 아니다.)</p>

<h2 id="로그인-예제">로그인 예제</h2>

<p>일단 유저가 권한획득을 한다면, 당신은 <a href="">login_user</a> 함수를 통해서 그들을 로그인 시킨다.</p>

<p>예제 :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@app.route</span><span class="p">(</span><span class="s">'/login'</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">'GET'</span><span class="p">,</span> <span class="s">'POST'</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="c"># Here we use a class of some kind to represent and validate our</span>
    <span class="c"># client-side form data. For example, WTForms is a library that will</span>
    <span class="c"># handle this for us, and we use a custom LoginForm to validate.</span>
    <span class="n">form</span> <span class="o">=</span> <span class="n">LoginForm</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">form</span><span class="o">.</span><span class="n">validate_on_submit</span><span class="p">():</span>
        <span class="c"># Login and validate the user.</span>
        <span class="c"># user should be an instance of your `User` class</span>
        <span class="n">login_user</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>

        <span class="n">flask</span><span class="o">.</span><span class="n">flash</span><span class="p">(</span><span class="s">'Logged in successfully.'</span><span class="p">)</span>

        <span class="nb">next</span> <span class="o">=</span> <span class="n">flask</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'next'</span><span class="p">)</span>
        <span class="c"># is_safe_url should check if the url is safe for redirects.</span>
        <span class="c"># See http://flask.pocoo.org/snippets/62/ for an example.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_safe_url</span><span class="p">(</span><span class="nb">next</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">flask</span><span class="o">.</span><span class="n">abort</span><span class="p">(</span><span class="mi">400</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">flask</span><span class="o">.</span><span class="n">redirect</span><span class="p">(</span><span class="nb">next</span> <span class="ow">or</span> <span class="n">flask</span><span class="o">.</span><span class="n">url_for</span><span class="p">(</span><span class="s">'index'</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">flask</span><span class="o">.</span><span class="n">render_template</span><span class="p">(</span><span class="s">'login.html'</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="n">form</span><span class="p">)</span>
</code></pre></div></div>

<p><em>경고 :</em> 당신은 <strong>반드시</strong> <a href="">next</a> 파라미터의 유효성을 검사해야 한다. 만일 이것을 하지 않으면, 당신의 어플리케이션은 오픈 리다이렉트(open redirects)에 취약해질 것이다. is_safe_url의 구현 예시를 보려면 이 <a href="http://flask.pocoo.org/snippets/62/">Flask Snippet</a>을 참고하라.</p>

<blockquote>
  <p>참고(역주) - <strong>오픈 리다이렉트</strong> : 명확한 URL을 사용하지 않고, 사용자로부터 받은 파라미터 정보를 그대로 리다이렉트 하는 경우 발생되는 취약점. 국문으로 번역하여 “공개된 재전송” 이라고 부르는 문서도 있으나 여기서는 영문 그대로 독음하여 번역하였다. 참고 : <a href="http://horae.tistory.com/entry/Open-Redirect-Cheat-sheet">티스토리 블로그</a></p>
</blockquote>

<p>이렇게나 간단하다. 당신은 모든 템플릿에서 사용 가능한 <a href="#flask_login.current_user">current_user</a> 프록시를 통해 로그인한 유저 정보에 접근할 수 있다 :</p>

<pre><code class="language-jinja2">
</code></pre>

<p>로그인 할 당신의 유저정보를 요청하는 화면은 <a href="#flask_login.login_required">login_required</a> 를 통해서 장식될 수 있다 :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@app.route</span><span class="p">(</span><span class="s">"/settings"</span><span class="p">)</span>
<span class="nd">@login_required</span>
<span class="k">def</span> <span class="nf">settings</span><span class="p">():</span>
    <span class="k">pass</span>
</code></pre></div></div>

<p>유저가 로그아웃 할 준비가 되었다면 :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@app.route</span><span class="p">(</span><span class="s">"/logout"</span><span class="p">)</span>
<span class="nd">@login_required</span>
<span class="k">def</span> <span class="nf">logout</span><span class="p">():</span>
    <span class="n">logout_user</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="n">somewhere</span><span class="p">)</span>
</code></pre></div></div>

<p>그들은 로그아웃 될 것이다. 그리고 그들의 세션의 어떤 쿠키도 정리될 것이다.</p>

<h2 id="로그인-프로세스-커스터마이징">로그인 프로세스 커스터마이징</h2>

<p>기본으로 유저가 로그인 되지 않은 상태에서 <a href="#flask_login.login_required">login_required</a> 화면에 접근하려고 할 때, Flask-Login은 메시지를 보여주고 로그인 화면으로 리다이렉트 할 것이다. (만일 로그인 화면이 세팅되어있지 않다면, 401에러를 내고 종료될 것이다.)</p>

<p>로그인 화면의 이름은 <a href="#flask_login.LoginManager.login_view">LoginManager.login_view</a>로 셋팅될 수 있다. 예제를 보면 :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">login_manager</span><span class="o">.</span><span class="n">login_view</span> <span class="o">=</span> <span class="s">"users.login"</span>
</code></pre></div></div>

<p>기본으로 보여주는 메시지는 “Please log in to access this page.” 이다. 이 메시지를 편집하려면 <a href="#flask_login.LoginManager.login_message">LoginManager.login_message</a>를 셋팅하면 된다 :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">login_manager</span><span class="o">.</span><span class="n">login_message</span> <span class="o">=</span> <span class="s">u"Bonvolu ensaluti por uzi tiun paĝon."</span>
</code></pre></div></div>

<p>이 메시지 카테고리를 편집하려면 <strong>LoginManager.login_message_category</strong>를 셋팅한다 :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">login_manager</span><span class="o">.</span><span class="n">login_message_category</span> <span class="o">=</span> <span class="s">"info"</span>
</code></pre></div></div>

<p>로그인 화면으로 리다이렉트 될 때, 쿼리스트링에 <strong>next</strong> 변수를 가지고 있을 것이다. 이 변수는 유저가 접근하려고 시도했던 페이지를 가리킨다. 또는 <strong>USE_SESSION_FOR_NEXT</strong>가 <a href="https://docs.python.org/3/library/constants.html#True">True</a>라면, 그 페이지는 세션 내부에 <strong>next</strong> 키로 저장된다.</p>

<p>만일 이 프로세스를 더 커스터마이징 하고싶다면, <a href="#flask_login.LoginManager.unauthorized_handler">LoginManager.unauthorized_handler</a>로 함수를 장식하라 :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@login_manager.unauthorized_handler</span>
<span class="k">def</span> <span class="nf">unauthorized</span><span class="p">():</span>
    <span class="c"># do stuff</span>
    <span class="k">return</span> <span class="n">a_response</span>
</code></pre></div></div>

<h2 id="authorization-header를-사용한-로그인">Authorization header를 사용한 로그인</h2>

<blockquote>
  <p>주의! : 이 메서드는 더이상 사용되지 않을 예정이다. 대신 아래의 <strong>request_loader</strong> 를 사용하라.</p>
</blockquote>

<p>때때로 당신은 Authorization header를 활용한 기본 권한 로그인을 지원하기를 원할 것이다. header를 통한 로그인을 지원하려면 당신은 header_loader 콜백함수 제공이 필요할 것이다. 이 콜백은 user id 대신에 header 값을 받는다는 것을 제외하면, 당신의 user_loader 콜백과 동일게 동작해야 한다. 예제를 보자 :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@login_manager.header_loader</span>
<span class="k">def</span> <span class="nf">load_user_from_header</span><span class="p">(</span><span class="n">header_val</span><span class="p">):</span>
    <span class="n">header_val</span> <span class="o">=</span> <span class="n">header_val</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">'Basic '</span><span class="p">,</span> <span class="s">''</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">header_val</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">header_val</span><span class="p">)</span>
    <span class="k">except</span> <span class="nb">TypeError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">return</span> <span class="n">User</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">api_key</span><span class="o">=</span><span class="n">header_val</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
</code></pre></div></div>

<p>기본으로 Authorization header 값은 당신의 header_loader 콜백에 전달된다. 이 값은 AUTH_HEADER_NAME 설정을 사용함으로서 변경할 수 있다.</p>

<h2 id="request-loader를-활용한-커스텀-로그인">Request Loader를 활용한 커스텀 로그인</h2>

<p>때때로 당신은 쿠키(header 값이나 질의어로 전달된 api key)를 사용하지 않고 유저를 로그인 시키기를 원할 것이다. 이런 경우에는 <strong>request_loader</strong> 콜백을 사용해야 한다. 이 콜백은 user_id 대신에 Flask request를 받는다는 것을 제외하면, 당신의 <a href="#flask_login.LoginManager.user_loader">user_loader</a> 콜백과 동일하게 동작해야 한다.</p>

<p>예를 들어, URL 인자와 <strong>Authorization</strong> header를 이용한 Basic Auth를 둘다 지원하는 것을 보자 :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@login_manager.request_loader</span>
<span class="k">def</span> <span class="nf">load_user_from_request</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>

    <span class="c"># first, try to login using the api_key url arg</span>
    <span class="n">api_key</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'api_key'</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">api_key</span><span class="p">:</span>
        <span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">api_key</span><span class="o">=</span><span class="n">api_key</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">user</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">user</span>

    <span class="c"># next, try to login using Basic Auth</span>
    <span class="n">api_key</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">headers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'Authorization'</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">api_key</span><span class="p">:</span>
        <span class="n">api_key</span> <span class="o">=</span> <span class="n">api_key</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">'Basic '</span><span class="p">,</span> <span class="s">''</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">api_key</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">api_key</span><span class="p">)</span>
        <span class="k">except</span> <span class="nb">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">api_key</span><span class="o">=</span><span class="n">api_key</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">user</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">user</span>

    <span class="c"># finally, return None if both methods did not login the user</span>
    <span class="k">return</span> <span class="bp">None</span>
</code></pre></div></div>

<h2 id="익명-유저">익명 유저</h2>

<p>기본으로, 실제로 로그인 하지 않은 유저는 <strong>current_user</strong>가 <strong>AnonymousUserMixin</strong> 객체로 셋팅된다. 이것은 아래의 프로퍼티와 메서드를 가진다 :</p>

<ul>
  <li><strong>is_active</strong>와 <strong>is_authenticated</strong>는 <a href="https://docs.python.org/3/library/constants.html#False">False</a></li>
  <li><strong>is_anonymouse</strong>는 <a href="https://docs.python.org/3/library/constants.html#True">True</a></li>
  <li><strong>get_id()</strong> 는 <a href="https://docs.python.org/3/library/constants.html#None">None</a>을 리턴</li>
</ul>

<p>만일 당신이 익명 유저에 대한 커스텀 요구사항을 가지고 있다면(예를 들어, 그들에게 허가 필드가 필요할 수도 있다.), 당신은 <strong>LoginManager</strong>를 가지는 익명 유저를 생성해주는 callable(클래스 혹은 생성함수)을 제공할 수 있다 :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">login_manager</span><span class="o">.</span><span class="n">anonymous_user</span> <span class="o">=</span> <span class="n">MyAnonymousUser</span>
</code></pre></div></div>

<h2 id="remember-me">Remember Me</h2>

<p>기본적으로, 유저가 브라우저를 닫으면 Flask 세션은 삭제되고 유저는 로그아웃 처리된다. “Remember Me”는 유저가 브라우저를 닫을 때, 의도치않게 로그아웃 되는 것을 방지한다. 이것이 유저가 로그아웃 한 후에도 유저의 username 혹은 password를 기억한다는 것을 의미하지는 <strong>않는다</strong>.</p>

<p>“Remember Me” 함수는 구현하기 까다로울 수도 있다. 그러나 Flask-Login은 이것을 거의 투명하게(단지 remember=True를 <strong>login_user</strong>에 전달하는 것 만으로) 만들어준다. 쿠키는 유저의 컴퓨터에 저장될 것이다. 그리고나서 세션에 유저정보가 없다면, Flask-Login은 쿠키에 있는 user ID를 자동으로 복원한다. 쿠키는 위조방지이기 때문에, 유저가 조작하려고 하면(본인 ID 대신에 다른 유저의 ID를 넣으려고 하는 등) 없던 것처럼 거부될 것이다.</p>

<p>그 정도 레벨의 기능은 자동으로 처리된다. 하지만 당신이 쿠키의 보안을 증가시키고 싶다면 추가적인 하부구조를 제공할 수 있다.</p>

<h2 id="대체-토큰alternative-tokens">대체 토큰(Alternative Tokens)</h2>

<p>user ID를 토큰을 기억하기 위한 값으로 사용하는 것은 당신이 사용자의 ID를 그들의 로그인 세션에서 유효하지 않은 값으로 변경해야 함을 의미한다. 이것을 개선하기 위한 한 방법은 사용자의 ID 대신 대체 세션 토큰을 사용하는 것이다. 예제를 보자 :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@login_manager.user_loader</span>
<span class="k">def</span> <span class="nf">load_user</span><span class="p">(</span><span class="n">session_token</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">User</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">session_token</span><span class="o">=</span><span class="n">session_token</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
</code></pre></div></div>

<p>그리고 나면 당신의 User 클래스의 <strong>get_id</strong> 메서드는 사용자 ID 대신 세션 토큰을 리턴할 것이다 :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">unicode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session_token</span><span class="p">)</span>
</code></pre></div></div>

<p>이 방법은 유저가 비밀번호를 변경했을 때, 당신이 자유롭게 유저의 세션토큰을 무작위로 생성된 값으로 변경하도록 해준다. 이것은 기존의 권한이 있는 세션이 유효한 세션을 위해서 중단될 것임을 확신할 수 있도록 해준다. 마치 두번째 유저 ID인 것처럼, 세션토큰은 반드시 유저마다 유니크한 값을 가져야 한다는 것을 기억하라.</p>

<h2 id="fresh-logins">Fresh Logins</h2>

<p>유저가 로그인할 때, 그들의 세션은 “새로운(fresh)” 마크가 붙는다. 이것은 실질적으로 그 세션에 권한을 획득했음을 나타낸다. 그들의 세션이 없어지고 “remember me” 쿠키를 통해서 다시 로그인할 때, 이 세션은 “새롭지 않은(non-fresh)” 마크가 붙는다.</p>

<p><strong>login_required</strong> 는 새로운지 아닌지를 구별하지 않는다. 이것은 대부분의 페이지에서는 괜찮다. 그러나 누군가의 개인정보를 변경하는 것과 같은 민감한 행동은 새로운 로그인을 요구해야 한다. (누군가의 비밀번호를 변경하는 행동은 항상 비밀번호 재입력을 요구해야 한다.)</p>

<p>유저가 로그인했다는 것을 확인하는 것 이외에, <strong>fresh_login_required</strong> 은 그들의 로그인이 새롭다는 것을 확인시켜줄 것이다. 그렇지 않다면, 그들의 인증을 다시 받을 수 있는 페이지로 보낼 것이다. <strong>LoginManager.refresh_view</strong>, <strong>needs_refresh_message</strong>, needs_refresh_message_category를 셋팅함으로써 당신은 <strong>login_required</strong>를 커스터마이징 했던 방식과 동일하게 그 행동을 커스터마이징 할 수 있다 :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">login_manager</span><span class="o">.</span><span class="n">refresh_view</span> <span class="o">=</span> <span class="s">"accounts.reauthenticate"</span>
<span class="n">login_manager</span><span class="o">.</span><span class="n">needs_refresh_message</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s">u"To protect your account, please reauthenticate to access this page."</span>
<span class="p">)</span>
<span class="n">login_manager</span><span class="o">.</span><span class="n">needs_refresh_message_category</span> <span class="o">=</span> <span class="s">"info"</span>
</code></pre></div></div>

<p>혹은 콜백함수를 제공함으로써 refresh를 처리한다 :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@login_manager.needs_refresh_handler</span>
<span class="k">def</span> <span class="nf">refresh</span><span class="p">():</span>
    <span class="c"># do stuff</span>
    <span class="k">return</span> <span class="n">a_response</span>
</code></pre></div></div>

<p>세션에 다시 “새로움” 마크를 붙이려면 <strong>confirm_login</strong> 함수를 콜한다.</p>

<h2 id="쿠키-셋팅">쿠키 셋팅</h2>

<p>어플리케이션 셋팅에서 쿠키의 상세정보를 커스터마이징 할 수 있다.</p>

<table>
  <thead>
    <tr>
      <th>변수명</th>
      <th>설명 및 기본값</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>REMEMBER_COOKIE_NAME</td>
      <td>“remember me” 정보를 저장하기 위한 쿠키의 이름. <strong>기본값 :</strong> remember_token</td>
    </tr>
    <tr>
      <td>REMEMBER_COOKIE_DURATION</td>
      <td>쿠키가 만료되기까지 남은 시간 datatime.timedelta 객체에 담긴다. <strong>기본값 :</strong> 365일(1 non-leap Gregorian year)</td>
    </tr>
    <tr>
      <td>REMEMBER_COOKIE_DOMAIN</td>
      <td>“Remember Me” 쿠키가 도메인을 넘어간다면, 도메인 값을 여기에 셋팅한다(.example.com 과 같이 입력하면 example.com의 모든 서브도메인에서 쿠키사용을 허가한다.). <strong>기본값 : None</strong></td>
    </tr>
    <tr>
      <td>REMEMBER_COOKIE_PATH</td>
      <td>“Remember Me” 쿠키의 특정 경로. <strong>기본값 : /</strong></td>
    </tr>
    <tr>
      <td>REMEMBER_COOKIE_SECURE</td>
      <td>보안채널(HTTPS등)의 “Remember Me” 쿠키의 범위를 정해준다. <strong>기본값 : None</strong></td>
    </tr>
    <tr>
      <td>REMEMBER_COOKIE_HTTPONLY</td>
      <td>“Remember Me” 쿠키에 클라이언트의 스크립트 접근을 방지한다. <strong>기본값 : False</strong></td>
    </tr>
  </tbody>
</table>

<h2 id="세션-보호">세션 보호</h2>

<p>쿠키도둑으로부터 “Remember Me” 토큰을 보호하는 것을 도와주는 기능들이 동작하고 있더라도, 세션쿠키는 여전히 취약하다. Flask-Login은 당신의 유저세션이 도난당하는 것을 방지하는 세션 보호를 포함하고 있다.</p>

<p>당신은 <strong>LoginManager</strong>과 어플리케이션의 설정에서 세션보호를 설정할 수 있다. 사용 가능하다면 <strong>basic</strong> 혹은 <strong>strong</strong> 모드 둘 다 작동하게 할 수있다. <strong>LoginManager</strong>에서 셋팅할 경우, <strong>session_protection</strong> 항목을 “basic”이나 “strong”으로 설정한다 :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">login_manager</span><span class="o">.</span><span class="n">session_protection</span> <span class="o">=</span> <span class="s">"strong"</span>
</code></pre></div></div>

<p>셋팅을 하지 않으려면 :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">login_manager</span><span class="o">.</span><span class="n">session_protection</span> <span class="o">=</span> <span class="bp">None</span>
</code></pre></div></div>

<p>기본적으로는 “basic” 모드가 활성화 되어있다. 어플리케이션 설정에서 <strong>SESSION_PROTECTION</strong> 을 None, “basic”, “strong”으로 셋팅함으로써 위의 설정을 무효화 할 수 있다.</p>

<p>세션 보호가 활성화 될 때, 각각의 요청은 유저의 컴퓨터에 식별자(기본적으로, IP주소와 유저 에이전트의 안전한 해시값)를 생성한다. 만일 세션이 관련된 식별자가 없다면, 생성된 것이 저장될 것이다. 만일 식별자가 있다면, 그리고 생성된 것과 일치한다면 요청은 올바르게 처리된다.</p>

<p>만일 <strong>basic</strong> 모드에서 식별자가 일치하지 않거나, 세션이 영구적일 때, 세션은 간단하게 “새롭지 않은(non-fresh)” 마크가 붙을 것이다. 그리고 어떤 “새로운(fresh)” 로그인 요청이라도 유저가 다시 권한을 획득하도록 강제할 것이다(물론, 당신은 적절한 곳에서 이미 fresh login을 사용하고 있어야 한다.).</p>

<p>만일 <strong>strong</strong> 모드에서 영구적이지 않은 세션의 식별자가 일치하지 않으면, 전체 세션(remember token이 존재한다면 그것도 함께)이 삭제된다.</p>

<h2 id="disabling-session-cookie-for-apis">Disabling Session Cookie for APIs</h2>

<p>API를 인증할 때, 당신은 Flask 세션 쿠키의 설정을 비활성화 하고 싶을 것이다. 그렇게 하려면, 당신이 요청에서 셋팅한 플래그를 이용해서 세션저장을 건너뛰도록 해주는 커스텀 세션 인터페이스를 사용하라. 예제를 보자 :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">g</span>
<span class="kn">from</span> <span class="nn">flask.sessions</span> <span class="kn">import</span> <span class="n">SecureCookieSessionInterface</span>
<span class="kn">from</span> <span class="nn">flask_login</span> <span class="kn">import</span> <span class="n">user_loaded_from_header</span>

<span class="k">class</span> <span class="nc">CustomSessionInterface</span><span class="p">(</span><span class="n">SecureCookieSessionInterface</span><span class="p">):</span>
    <span class="s">"""Prevent creating session from API requests."""</span>
    <span class="k">def</span> <span class="nf">save_session</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'login_via_header'</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">CustomSessionInterface</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">save_session</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span>
                                                                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="n">app</span><span class="o">.</span><span class="n">session_interface</span> <span class="o">=</span> <span class="n">CustomSessionInterface</span><span class="p">()</span>

<span class="nd">@user_loaded_from_header.connect</span>
<span class="k">def</span> <span class="nf">user_loaded_from_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">g</span><span class="o">.</span><span class="n">login_via_header</span> <span class="o">=</span> <span class="bp">True</span>
</code></pre></div></div>

<p>이것은 사용자가 당신의 <strong>header_loader</strong>를 사용해서 권한을 획득할 때면 언제든지 Flask 세션쿠키의 셋팅을 막아준다.</p>

<h2 id="localization">Localization</h2>

<p>기본값으로, 유저가 로그인을 요청할 때, <strong>LoginManager</strong>는 메시지를 보여주는데 flash를 사용한다. 이 메시지들은 영문이다. 만일 당신이 지역화(localization)를 원한다면, <strong>LoginManager</strong>의 <strong>localize_callback</strong> 항목을 이 메시지들이 flash로 보내지기 전에 불러지는 함수(gettext와 같은)로 셋팅하라. 이 함수는 메시지와 함께 실행될 것이다. 그리고 리턴값이 대신 flash로 전달될 것이다.</p>


  </div>
  
</article>


        
<div id="disqus_thread"></div>
<script>

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = '//golch51.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



      </div>
    </div>
    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">GOLCH</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>GOLCH</li>
          <li><a href="mailto:p2r64h32@gmail.com">p2r64h32@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/golch"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">golch</span></a>

          </li>
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>개발자 골치의 블로그입니다. 주로 웹기술 관련 내용을 다룹니다.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
